{"manifest":"v1","id":{"name":"rest","version":"0.3.5"},"kind":{"FieldResolver":{"resolver_directives":["rest"]}},"sdk_version":"0.8.0","minimum_gateway_version":"0.29.0","description":"Declarative REST resolver extension.","sdl":"extend schema\n    @link(\n        url: \"https://specs.grafbase.com/grafbase\"\n        import: [\"InputValueSet\", \"UrlTemplate\", \"JsonTemplate\"]\n    )\n\n\"\"\"\n@restEndpoint directive enables defining named REST endpoints for the\nschema. The directive can be used multiple times on a schema to\ndefine different endpoints.\n\nExample:\nextend schema\n  @restEndpoint(name: \"weather\", baseURL: \"https://api.weather.com\")\n  @restEndpoint(name: \"users\", baseURL: \"https://api.users.example.com\")\n\"\"\"\ndirective @restEndpoint(\n    \"\"\"\n    A unique identifier for the REST endpoint\n    \"\"\"\n    name: String!\n    \"\"\"\n    The base URL for the REST API\n    \"\"\"\n    baseURL: String!\n) repeatable on SCHEMA\n\n\"\"\"\n@rest directive allows you to define RESTful API integrations for GraphQL\nfields. This directive maps GraphQL fields to REST endpoints, enabling\nseamless integration between your GraphQL schema and external REST APIs.\n\nExample:\ntype Query {\n  users: [User] @rest(\n    endpoint: \"users\",\n    method: GET,\n    path: \"/users\",\n    selection: \"*\"\n  )\n}\n\"\"\"\ndirective @rest(\n    \"\"\"\n    The name of the REST endpoint to use, as defined by @restEndpoint\n    \"\"\"\n    endpoint: String!\n\n    \"\"\"\n    The HTTP method to use for the request, such as GET, POST, etc.\n    \"\"\"\n    method: HttpMethod!\n\n    \"\"\"\n    The path template for the request, which can include\n    variable substitutions from GraphQL arguments.\n    This supports templating using GraphQL arguments: {{args.myArgument}}\n    \"\"\"\n    path: UrlTemplate!\n\n    \"\"\"\n    Specifies which fields from the GraphQL selection to include in the\n    response.\n    \"\"\"\n    selection: JsonTemplate!\n\n    \"\"\"\n    Configuration for the request body, can include static values or\n    selections from the GraphQL arguments\n    \"\"\"\n    body: Body = { selection: \"*\" }\n) on FIELD_DEFINITION\n\nscalar JSON\n\n\"\"\"\nBody input type defines how to construct the request body for REST\nAPI calls. It allows for dynamic construction from GraphQL arguments\nor static values.\n\"\"\"\ninput Body {\n    \"\"\"\n    Specifies which GraphQL arguments to include in the request body.\n    Use \"*\" to include all arguments, or provide specific field names.\n    \"\"\"\n    selection: InputValueSet\n\n    \"\"\"\n    Static JSON content to include in the request body,\n    which will be merged with any selected values.\n    \"\"\"\n    static: JSON\n}\n\n\"\"\"\nHttpMethod enum represents the standard HTTP methods supported\nfor REST API interactions.\n\"\"\"\nenum HttpMethod {\n    \"\"\"\n    HTTP GET method for retrieving resources\n    \"\"\"\n    GET\n    \"\"\"\n    HTTP POST method for creating resources\n    \"\"\"\n    POST\n    \"\"\"\n    HTTP PUT method for replacing resources\n    \"\"\"\n    PUT\n    \"\"\"\n    HTTP DELETE method for removing resources\n    \"\"\"\n    DELETE\n    \"\"\"\n    HTTP HEAD method for retrieving headers only\n    \"\"\"\n    HEAD\n    \"\"\"\n    HTTP OPTIONS method for describing communication options\n    \"\"\"\n    OPTIONS\n    \"\"\"\n    HTTP CONNECT method for establishing tunnels\n    \"\"\"\n    CONNECT\n    \"\"\"\n    HTTP TRACE method for diagnostic testing\n    \"\"\"\n    TRACE\n    \"\"\"\n    HTTP PATCH method for partial modifications\n    \"\"\"\n    PATCH\n}\n","readme":"# REST Extension\n\nThis is a REST extension for the Grafbase Gateway. It allows you to define REST endpoints and map them to GraphQL fields. It provides two directives:\n\n- `@restEndpoint`, which you can repeat on the schema, defines a REST endpoint.\n- `@rest`, defined on a field, specifies which endpoint the field uses, which path and method it uses and how it selects data from the REST response.\n\n## Installing\n\nAdd the following to your gateway configuration (\"grafbase.toml\"):\n\n```toml\n[extensions.rest]\nversion = \"0.3\"\n```\n\nThen run `grafbase extension install`. The extension will be installed in the `grafbase_extensions` directory. That directory must be present when the gateway is started.\n\n## Building from source\n\nBuild this extension manually and copy the artifacts to a location where the gateway can find them until we complete the Grafbase Extension Registry.\n\n```bash\ngrafbase extension build\n```\n\nThe `build` directory contains the resulting wasm component and manifest file.\n\n```bash\nbuild/\n├── extension.wasm\n└── manifest.json\n```\n\nIn your gateway configuration, you can now load the extension from the `build` directory.\n\n```toml\n[extensions.rest]\npath = \"/path/to/build\"\n```\n\n## Configuration\n\nThis extension acts as a field resolver for the Grafbase Gateway. Use it as a subgraph to provide a REST translator to GraphQL for the gateway.\n\nThe extension provides two directives:\n\n- `@restEndpoint`, which you can repeat on the schema, defines a REST endpoint.\n- `@rest`, defined on a field, specifies which endpoint the field uses, which path and method it uses and how it selects data from the REST response.\n\nDefine your REST endpoint in your subgraph definition:\n\n```graphql\nextend schema\n  @link(url: \"https://specs.apollo.dev/federation/v2.0\", import: [\"@key\", \"@shareable\"])\n  @link(url: \"https://grafbase.com/extensions/rest/0.3.4\", import: [\"@restEndpoint\", \"@rest\"])\n\n@restEndpoint(\n  name: \"restCountries\",\n  baseURL: \"https://restcountries.com/v3.1\"\n)\n```\n\nThe `@restEndpoint` takes a unique name per subgraph, which you must refer to in the corresponding `@rest` directives, and a `baseURL`.\n\nThe `@rest` directive goes to a field directive:\n\n```graphql\ntype Country {\n  name: String!\n}\n\ntype Query {\n  listAllCountries: [Country!]! @rest(\n      method: GET\n      endpoint: \"restCountries\"\n      path: \"/all\"\n      selection: \"[.[] | { name: .name.official }]\"\n    )\n\n}\n```\n\nThe `endpoint` argument must match one `@restEndpoint` definition in the same subgraph. The `http` arguments define the method and a path for this endpoint, and the `selection` defines how the data transforms from the REST endpoint to a GraphQL subgraph response.\n\nIn our example we query countries from a public endpoint, which returns JSON. If we curl the API:\n\n```bash\ncurl https://restcountries.com/v3.1/all |jq |head -n100\n```\n\nOur data looks something like this:\n\n```json\n[\n  {\n    \"name\": {\n      \"common\": \"South Georgia\",\n      \"official\": \"South Georgia and the South Sandwich Islands\",\n      \"nativeName\": {\n        \"eng\": {\n          \"official\": \"South Georgia and the South Sandwich Islands\",\n          \"common\": \"South Georgia\"\n        }\n      }\n    },\n    ...\n  }\n}\n```\n\nNow, our GraphQL type for `Country` has only one field: the name. The `selection` argument in the `@rest` directive supports [jq filters](https://jqlang.org/manual/). First try the selection filter in the terminal with curl and jq. Convert the API endpoint from what we see above to the following, which should fit our GraphQL type definition:\n\n```graphql\ntype Country {\n  name: String!\n}\n```\n\nThe extension JSON output should have objects with the `name` key and the values must be strings. No nulls are allowed.\n\nRun the following curl command:\n\n```bash\ncurl https://restcountries.com/v3.1/all |jq \"[.[] | { name: .name.official }]\"\n```\n\nYou'll get output:\n\n```json\n[\n  {\n    \"name\": \"South Georgia and the South Sandwich Islands\"\n  },\n  {\n    \"name\": \"Grenada\"\n  },\n  ...\n]\n```\n\nSave the subgraph schema we just defined into a file, and publish it to the Grafbase platform\n\n```bash\ngrafbase publish --name countries -m init my-org/my-federated-graph\n```\n\nYou can omit the `--url` parameter from a subgraph that only acts as a virtual graph for an extension.\n\n### Headers\n\nThe REST extension sends headers to the REST endpoint. The resolver filters the request headers and uses the resulting subgraph headers.\n\nWhen you compose the REST subgraph to your federated graph, and you give it a name, you can define the [header rules](https://grafbase.com/docs/reference/gateway/configuration/subgraph-configuration#header-rules) in your gateway configuration.\n\n## Request Body\n\nUse the `body` argument to send data to the REST endpoint. The `body` argument accepts a JSON object or a selection that maps data from the input arguments.\n\nTo send dynamic data from the input arguments, add a selection to the body. The extension looks for a body in an argument named `input`. Use this name to follow the expected convention:\n\n```graphql\ntype Mutation {\n  createCountry(input: Country!): Country! @rest(\n    endpoint: \"restCountries\",\n    http: {\n      method: POST,\n      path: \"/create\"\n    },\n    selection: \"{ name: .name.official }\"\n  )\n}\n```\n\nYou can also use static data in the body:\n\n```graphql\ntype Mutation {\n  createCountry: Country! @rest(\n    endpoint: \"restCountries\",\n    method: POST,\n    path: \"/create\"\n    body: { static: { name: \"Georgia\" } },\n    selection: \"{ name: .name.official }\"\n  )\n}\n```\n\nThe extension checks static data first, then searches for a body in an argument named `input`.\n\n## Arguments\n\nThe path argument is used to specify the path to the REST endpoint. You can use the input arguments to construct the path:\n\n```graphql\ntype Mutation {\n  getCountry(id: Int!): Country @rest(\n    endpoint: \"restCountries\",\n    method: GET,\n    path: \"/fetch/{{ args.id }}\"\n    selection: \"{ name: .name.official }\"\n  )\n}\n```\n\nThe extension will generate the path based on the `id` argument.\n","repository_url":"https://github.com/grafbase/extensions/tree/main/extensions/rest","license":"Apache-2.0","permissions":["network"]}